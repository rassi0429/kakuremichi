# kakuremichi - 要件定義

## 1. プロジェクト概要

### 1.1 プロジェクト説明
CloudFlare Tunnelのようなリバースプロキシシステム。
アプリケーション側のサーバーでポートを開けることなく、外部からのアクセスを可能にする。

**基本的な仕組み**:
- アプリケーション側（オリジンサーバー）からアウトバウンド接続のみを行う
- 複数の入口ノード（プロキシサーバー）がトンネルを介して通信を中継
- ファイアウォールやNATの背後にあるサービスを安全に公開できる

**システム構成**:
```
■ コントロールプレーン（管理・設定）:
┌─────────┐
│ Control │
└─────────┘
  ↓WebSocket  ↓WebSocket
  (設定配信)  (設定配信)
  ↓           ↓
[Gateway]   [Agent]
 #1, #2, #3

■ データプレーン（実際のトラフィック、Controlを経由しない）:
外部ユーザー
    ↓
[Gateway] ─トンネル→ [Agent] → アプリ
```

**コンポーネント名**:
- **Control**: 中央管理サーバー（コントロールプレーン）
- **Gateway**: 入口ノード（複数配置可能）
- **Agent**: エッジクライアント（オリジン側）

**重要な設計思想**:
- **コントロールプレーンとデータプレーンの分離**: 管理・設定は中央管理サーバーが行うが、実際のトラフィックは中央管理サーバーを経由しない
- **スケーラビリティ**: 中央管理サーバーがボトルネックにならない
- **可用性**: 中央管理サーバーがダウンしても、既存の通信は継続可能

**主要な特徴**:
- **複数の入口ノード**: DDoS対策、負荷分散、可用性向上のため、入口ノードを複数配置可能
- **動的スケーリング**: 必要に応じて入口ノードを追加・削除できる
- **セルフホスト**: 自分のサーバーで運用可能
- **カスタマイズ可能**: 独自の要件に合わせて拡張可能
- **データ管理**: すべてのデータが自分の管理下に留まる

**CloudFlare Tunnelとの違い**:
- 複数の入口ノードを自由に配置・管理できる
- セルフホストによる完全なコントロール
- オープンソースでカスタマイズ可能

### 1.2 目的
- ファイアウォール背後のアプリケーションを安全に公開
- ポート開放不要でリモートアクセスを実現
- シンプルで使いやすいセルフホスト型トンネルシステムの提供

### 1.3 スコープ
**含むもの**:
- トンネル管理サーバー（中央プロキシ）
- エッジクライアント（オリジン側に配置）
- Web管理画面
- 基本的な認証・認可機能

**含まないもの（将来的に検討）**:
- CDN機能
- DDoS対策
- 高度なトラフィック解析

### 1.4 想定ユーザー
- 個人開発者（自宅サーバーの公開）
- 小規模チーム（社内アプリケーションの共有）
- 中規模組織（複数拠点のサービス統合）
- その他: IoTデバイスの管理、開発環境の共有

## 2. ユースケース

### ユースケース1: シンプルなWebアプリケーションの公開
**アクター**: 個人開発者

**前提条件**:
- 自宅サーバーでWebアプリ（例: Next.jsアプリ）がポート8080で動作している
- ファイアウォールの内側にあり、ポート開放したくない
- Controlサーバーは既にクラウド上で稼働している
- 独自ドメイン（例: fuga.sample.com）を持っている

**ストーリー**:
1. 開発者は自宅サーバーにAgentをインストールする
2. AgentにControl ServerのURLとAPI Keyを設定する
3. Agentが起動し、Controlに自動登録される
4. 開発者はControlの管理画面にアクセス
5. 「新しいトンネル」を作成し、以下のように設定:
   - ドメイン: `fuga.sample.com`
   - ターゲット: `localhost:8080`
6. 保存ボタンをクリック

**期待される動作**:
- Gatewayが自動的にトンネルを確立
- DNSで`fuga.sample.com`をGatewayに向ける（手動またはAPI連携）
- 外部ユーザーが`https://fuga.sample.com`にアクセスすると、自宅サーバーの8080ポートに転送される
- SSL証明書は自動取得（Let's Encrypt）
- **リバースプロキシを別途置く必要なし**（Gatewayが兼ねる）

---

### ユースケース2: 複数サービスの公開
**アクター**: 小規模チーム

**前提条件**:
- 社内ネットワークに複数のサービスが稼働
  - APIサーバー（ポート3000）
  - 管理画面（ポート8080）
  - データベース管理UI（ポート5432）
- 社外からアクセスしたい

**ストーリー**:
1. 社内サーバーにAgentをインストール
2. Controlの管理画面で複数のトンネルを設定:
   - `api.company.com` → `localhost:3000`
   - `admin.company.com` → `localhost:8080`
   - `db.company.com` → `localhost:5432`
3. それぞれにアクセス制御を設定（特定のユーザーのみアクセス可能）

**期待される動作**:
- 1つのAgentで複数のサービスを公開
- 各サービスごとにアクセス制御が適用される
- 外部からhttpsでアクセス可能

---

### ユースケース3: 高可用性構成
**アクター**: 中規模組織

**前提条件**:
- 重要なサービスをダウンタイムなく公開したい
- 複数のGatewayを配置可能

**ストーリー**:
1. 複数のクラウドリージョンにGatewayを配置（東京、シンガポール、アメリカ）
2. Controlの管理画面でGatewayを登録
3. サービスを設定する際、複数のGatewayを選択
4. DNSでラウンドロビンまたはGeoDNSを設定

**期待される動作**:
- 1つのGatewayがダウンしても他のGatewayが継続してサービス提供
- 地理的に近いGatewayに自動振り分け（DNSレベル）
- DDoS攻撃時に負荷分散

---

### ユースケース4: 開発環境の共有
**アクター**: フリーランス開発者

**前提条件**:
- ローカル開発環境（localhost:3000）でクライアントにデモを見せたい
- ngrokのような一時的なトンネルで十分

**ストーリー**:
1. Agentをインストール済み
2. CLIコマンドで一時トンネルを作成:
   ```
   agent tunnel --port 3000 --temporary
   ```
3. 自動生成されたURL（例: `random-abc123.tunnel.example.com`）が表示される
4. クライアントにURLを共有

**期待される動作**:
- 即座にトンネルが確立
- 一時的なランダムドメインが発行される
- Agentを停止するとトンネルも自動削除
- 管理画面での設定不要

---

### ユースケース5: Docker Composeで簡単公開
**アクター**: Docker利用者

**前提条件**:
- docker-composeでアプリケーションを動かしている
- リバースプロキシ（NginxやTraefik）を置きたくない
- 簡単に外部公開したい

**ストーリー**:
1. 既存のdocker-compose.ymlにAgentコンテナを追加:
   ```yaml
   services:
     app:
       image: my-app:latest
       ports:
         - "3000:3000"

     agent:
       image: kakuremichi/agent:latest
       environment:
         - CONTROL_URL=https://control.example.com
         - API_KEY=xxx
         - TUNNEL_DOMAIN=myapp.example.com
         - TUNNEL_TARGET=app:3000
   ```
2. `docker-compose up`で起動

**期待される動作**:
- Agentが自動的にControlに接続
- トンネルが自動確立
- `https://myapp.example.com`で外部からアクセス可能
- **SSL証明書はGatewayが自動取得（Let's Encrypt）**
- リバースプロキシを別途置く必要なし

**メリット**:
- docker-compose.ymlに数行追加するだけ
- Nginx、Traefik、Caddyなどのリバースプロキシ不要
- SSL証明書の設定・更新が完全自動

---

### ユースケース6: 完全自動SSL対応
**アクター**: インフラ初心者

**前提条件**:
- SSL証明書の取得方法がわからない
- certbotなどのツールを使いたくない
- ドメインは既に持っている

**ストーリー**:
1. ControlとGatewayを起動（初回のみ）
2. DNSでドメインをGatewayに向ける
3. Controlの管理画面でトンネルを作成:
   - ドメイン: `myapp.example.com`
   - ターゲット: `localhost:8080`
4. 保存

**期待される動作**:
- Gatewayが自動的にLet's Encryptから証明書を取得
- HTTPSが即座に有効になる
- 証明書の更新も自動（90日ごと）
- ユーザーは証明書について何も考えなくて良い

**技術的な実装**:
- GatewayにACME protocol対応（Let's Encrypt）
- HTTP-01チャレンジまたはTLS-ALPN-01チャレンジ
- 証明書の自動更新スケジューラー
- 証明書のストレージ（ファイルまたはDB）

---

**その他のユースケース（Phase 2以降）**: `roadmap.md`を参照

---

## 3. 機能要件

### 3.1 必須機能（Must Have）

#### 認証・認可
- [ ] ユーザー登録
- [ ] ログイン・ログアウト
- [ ] セッション管理
- [ ] アクセス制御（誰がどのサービスにアクセスできるか）
- [ ] その他:

#### トンネル管理
- [ ] トンネルの確立
- [ ] トンネルの切断
- [ ] トンネルステータスの監視
- [ ] 自動再接続
- [ ] その他:

#### サービス管理
- [ ] サービスの登録
- [ ] サービスの削除
- [ ] サービスの有効化・無効化
- [ ] サービス一覧表示
- [ ] その他:

#### 入口ノード管理（Gateway）
- [ ] 入口ノードの登録
- [ ] 入口ノードの削除
- [ ] 入口ノードのステータス監視
- [ ] 入口ノードの有効化・無効化
- [ ] 入口ノード間の負荷分散設定
- [ ] 入口ノードの動的追加（スケールアウト）
- [ ] 入口ノードのヘルスチェック
- [ ] **SSL証明書の自動取得（Let's Encrypt）**
- [ ] **SSL証明書の自動更新**
- [ ] **HTTPからHTTPSへの自動リダイレクト**
- [ ] その他:

#### クライアント管理（Agent）
- [ ] エッジクライアントの登録
- [ ] クライアント認証
- [ ] クライアントステータス監視
- [ ] クライアント設定の配布
- [ ] クライアントとGatewayの紐付け
- [ ] **Dockerコンテナとしての配布（MVP必須）**
- [ ] **Docker Composeサポート（環境変数での設定、MVP必須）**
- [ ] バイナリ配布（各OS対応）
- [ ] その他:

#### UI/管理画面
- [ ] ダッシュボード（全体の状態を把握）
- [ ] サービス管理画面
- [ ] ユーザー管理画面
- [ ] ログ・監視画面
- [ ] その他:

### 3.2 重要機能（Should Have）

- [ ] 複数組織のサポート
- [ ] ロールベースアクセス制御（RBAC）
- [ ] 監査ログ
- [ ] メトリクス収集（帯域幅、接続数など）
- [ ] アラート・通知機能
- [ ] API提供（管理操作をAPIで実行）
- [ ] CLI管理ツール
- [ ] **一時トンネル機能（ngrokライク）**
- [ ] **カスタムドメインサポート**
- [ ] **ワイルドカード証明書対応**
- [ ] その他:

### 3.3 あると良い機能（Nice to Have - MVP範囲内）

- [ ] カスタムドメインの高度な管理
- [ ] トンネルのプレビュー機能
- [ ] エラーページのカスタマイズ
- [ ] その他:

**Phase 2以降の機能**: `roadmap.md`を参照

## 4. 非機能要件

### 4.1 パフォーマンス
- **レイテンシ**:
  - 目標値:
  - 許容値:
- **スループット**:
  - 目標値:
  - 許容値:
- **同時接続数**:
  - 目標値:
  - 許容値:

### 4.2 セキュリティ
- [ ] 通信の暗号化（必須）
- [ ] 認証情報の安全な保管
- [ ] パスワードのハッシュ化
- [ ] セッションの安全な管理
- [ ] HTTPS強制
- [ ] Rate Limiting（DoS対策）
- [ ] その他:

**セキュリティ基準**:
- 準拠すべき規格・ガイドライン:

### 4.3 可用性
- **稼働率目標**:
- **ダウンタイム許容**:
- **バックアップ要件**:
- **災害復旧要件**:

### 4.4 スケーラビリティ
- **想定ユーザー数**:
  - 初期:
  - 1年後:
  - 3年後:
- **想定サービス数**:
  - 初期:
  - 1年後:
  - 3年後:
- **水平スケーリング**: 必要 / 不要
- **垂直スケーリング**: 必要 / 不要

### 4.5 保守性・運用性
- [ ] ログの収集と保管
- [ ] モニタリング機能
- [ ] ヘルスチェック
- [ ] 設定のバックアップ・リストア
- [ ] アップデート機能
- [ ] ロールバック機能
- [ ] その他:

### 4.6 移植性
- **サポートOS**:
  - サーバー側:
  - クライアント側:
- **デプロイ方法**:
  - [ ] バイナリ配布
  - [ ] Dockerコンテナ
  - [ ] Kubernetes
  - [ ] その他:

### 4.7 ユーザビリティ
- **ターゲット**: 技術者 / 非技術者 / 両方
- **ドキュメント要件**:
  - [ ] インストールガイド
  - [ ] ユーザーガイド
  - [ ] API仕様書
  - [ ] トラブルシューティングガイド
- **多言語対応**: 必要 / 不要
  - 対応言語:

## 5. 技術的制約

### 5.1 開発環境
- **プログラミング言語**:
- **フレームワーク**:
- **データベース**:
- **その他**:

### 5.2 実行環境
- **最小システム要件**:
  - CPU:
  - メモリ:
  - ストレージ:
  - ネットワーク:

### 5.3 外部依存
- **必須の外部サービス**:
- **オプションの外部サービス**:

### 5.4 ライセンス
- **採用予定ライセンス**:
- **利用可能なライブラリのライセンス制約**:

## 6. 制約条件

### 6.1 プロジェクト制約
- **開発期間**:
- **開発リソース**:
- **予算**:

### 6.2 技術的制約
- **使用できない技術**:
- **使用すべき技術**:

### 6.3 その他の制約
- **法規制**:
- **組織的制約**:

## 7. MVP（Phase 1）スコープ

**期間**: TBD
**目標**: 基本的なトンネル機能とDocker対応で動作するシステム

### 含める機能

**コアコンポーネント**:
- Control（管理サーバー）
  - 基本的なWebUI
  - REST API
  - WebSocketサーバー
  - データベース（SQLite）
- Gateway（入口ノード）
  - トンネル中継
  - SSL証明書自動取得（Let's Encrypt）
  - HTTPSリダイレクト
- Agent（エッジクライアント）
  - トンネル確立
  - ローカルプロキシ

**必須機能**:
- ✅ **Dockerコンテナとしての配布（3コンポーネント全て）**
- ✅ **Docker Composeサポート**
- ✅ ユーザー認証（登録・ログイン）
- ✅ トンネル管理（作成・削除・一覧・編集）
- ✅ Agent管理（登録・認証・ステータス監視）
- ✅ Gateway管理（登録・ステータス監視）
- ✅ SSL証明書自動取得・更新
- ✅ シンプルで使いやすいWebUI

### 含めない機能（Phase 2以降に延期）

- ❌ Kubernetes統合
- ❌ 複数組織サポート
- ❌ RBAC（ロールベースアクセス制御）
- ❌ 高度な監視・メトリクス
- ❌ OAuth/OIDC統合
- ❌ 一時トンネル機能
- ❌ CLI管理ツール
- ❌ バイナリ配布

**詳細は `roadmap.md` を参照**

### 実現できるユースケース

- ✅ ユースケース1: シンプルなWebアプリケーションの公開
- ✅ ユースケース2: 複数サービスの公開
- ✅ ユースケース5: Docker Composeで簡単公開
- ✅ ユースケース6: 完全自動SSL対応

### MVPの成功基準

**技術的成功基準**:
- [ ] `docker-compose up`一発で全コンポーネントが起動する
- [ ] Web UIでトンネルを作成できる
- [ ] SSL証明書が自動取得される
- [ ] 外部から`https://`でアクセスできる

**ユーザー体験**:
- [ ] 初めてのユーザーが30分以内にトンネルを張れる
- [ ] docker-compose.ymlに数行追加するだけで使える
- [ ] SSL証明書について何も考えなくて良い

---

## 8. 成功基準

### 8.1 技術的成功基準
- [ ]
- [ ]
- [ ]

### 8.2 ビジネス的成功基準
- [ ]
- [ ]
- [ ]

### 8.3 ユーザー満足度
- [ ]
- [ ]
- [ ]

## 9. リスクと対策

### リスク1:
**発生確率**: 高 / 中 / 低
**影響度**: 高 / 中 / 低
**対策**:

---

### リスク2:
**発生確率**: 高 / 中 / 低
**影響度**: 高 / 中 / 低
**対策**:

---

## 10. 未解決の課題・質問

-
-
-

---

**作成日**: 2025-11-22
**最終更新**: 2025-11-22
**バージョン**: 0.1
