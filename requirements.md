# kakuremichi - 要件定義

## 1. プロジェクト概要

### 1.1 プロジェクト説明
CloudFlare Tunnelのようなリバースプロキシシステム。
アプリケーション側のサーバーでポートを開けることなく、外部からのアクセスを可能にする。

**基本的な仕組み**:
- アプリケーション側（オリジンサーバー）からアウトバウンド接続のみを行う
- 複数の入口ノード（プロキシサーバー）がトンネルを介して通信を中継
- ファイアウォールやNATの背後にあるサービスを安全に公開できる

**システム構成**:
```
■ コントロールプレーン（管理・設定）:
┌─────────┐
│ Control │
└─────────┘
  ↓WebSocket  ↓WebSocket
  (設定配信)  (設定配信)
  ↓           ↓
[Gateway]   [Agent]
 #1, #2, #3

■ データプレーン（実際のトラフィック、Controlを経由しない）:
外部ユーザー
    ↓
[Gateway] ─トンネル→ [Agent] → アプリ
```

**コンポーネント名**:
- **Control**: 中央管理サーバー（コントロールプレーン）
- **Gateway**: 入口ノード（複数配置可能）
- **Agent**: エッジクライアント（オリジン側）

**重要な設計思想**:
- **コントロールプレーンとデータプレーンの分離**: 管理・設定は中央管理サーバーが行うが、実際のトラフィックは中央管理サーバーを経由しない
- **スケーラビリティ**: 中央管理サーバーがボトルネックにならない
- **可用性**: 中央管理サーバーがダウンしても、既存の通信は継続可能

**主要な特徴**:
- **複数の入口ノード**: DDoS対策、負荷分散、可用性向上のため、入口ノードを複数配置可能
- **動的スケーリング**: 必要に応じて入口ノードを追加・削除できる
- **セルフホスト**: 自分のサーバーで運用可能
- **カスタマイズ可能**: 独自の要件に合わせて拡張可能
- **データ管理**: すべてのデータが自分の管理下に留まる

**CloudFlare Tunnelとの違い**:
- 複数の入口ノードを自由に配置・管理できる
- セルフホストによる完全なコントロール
- オープンソースでカスタマイズ可能

### 1.2 目的
- ファイアウォール背後のアプリケーションを安全に公開
- ポート開放不要でリモートアクセスを実現
- シンプルで使いやすいセルフホスト型トンネルシステムの提供

### 1.3 スコープ
**含むもの**:
- トンネル管理サーバー（中央プロキシ）
- エッジクライアント（オリジン側に配置）
- Web管理画面
- 基本的な認証・認可機能

**含まないもの（将来的に検討）**:
- CDN機能
- DDoS対策
- 高度なトラフィック解析

### 1.4 想定ユーザー
- 個人開発者（自宅サーバーの公開）
- 小規模チーム（社内アプリケーションの共有）
- 中規模組織（複数拠点のサービス統合）
- その他: IoTデバイスの管理、開発環境の共有

## 2. ユースケース

### ユースケース1: シンプルなWebアプリケーションの公開
**アクター**: 個人開発者

**前提条件**:
- 自宅サーバーでWebアプリ（例: Next.jsアプリ）がポート8080で動作している
- ファイアウォールの内側にあり、ポート開放したくない
- Controlサーバーは既にクラウド上で稼働している
- 独自ドメイン（例: fuga.sample.com）を持っている

**ストーリー**:
1. 開発者は自宅サーバーにAgentをインストールする
2. AgentにControl ServerのURLとAPI Keyを設定する
3. Agentが起動し、Controlに自動登録される
4. 開発者はControlの管理画面にアクセス
5. 「新しいトンネル」を作成し、以下のように設定:
   - ドメイン: `fuga.sample.com`
   - ターゲット: `localhost:8080`
6. 保存ボタンをクリック

**期待される動作**:
- Gatewayが自動的にトンネルを確立
- DNSで`fuga.sample.com`をGatewayに向ける（手動またはAPI連携）
- 外部ユーザーが`https://fuga.sample.com`にアクセスすると、自宅サーバーの8080ポートに転送される
- SSL証明書は自動取得（Let's Encrypt）
- **リバースプロキシを別途置く必要なし**（Gatewayが兼ねる）

---

### ユースケース2: 複数サービスの公開
**アクター**: 小規模チーム

**前提条件**:
- 社内ネットワークに複数のサービスが稼働
  - APIサーバー（ポート3000）
  - 管理画面（ポート8080）
  - データベース管理UI（ポート5432）
- 社外からアクセスしたい

**ストーリー**:
1. 社内サーバーにAgentをインストール
2. Controlの管理画面で複数のトンネルを設定:
   - `api.company.com` → `localhost:3000`
   - `admin.company.com` → `localhost:8080`
   - `db.company.com` → `localhost:5432`
3. それぞれにアクセス制御を設定（特定のユーザーのみアクセス可能）

**期待される動作**:
- 1つのAgentで複数のサービスを公開
- 各サービスごとにアクセス制御が適用される
- 外部からhttpsでアクセス可能

---

### ユースケース3: 高可用性構成
**アクター**: 中規模組織

**前提条件**:
- 重要なサービスをダウンタイムなく公開したい
- 複数のGatewayを配置可能

**ストーリー**:
1. 複数のクラウドリージョンにGatewayを配置（東京、シンガポール、アメリカ）
2. Controlの管理画面でGatewayを登録
3. サービスを設定（ドメインとターゲットを指定）
   - **すべてのGatewayが自動的にこのサービスを処理可能になる**
   - Gatewayの個別選択は不要
4. DNSでラウンドロビンまたはGeoDNSを設定

**期待される動作**:
- 1つのGatewayがダウンしても他のGatewayが継続してサービス提供
- 地理的に近いGatewayに自動振り分け（DNSレベル）
- DDoS攻撃時に負荷分散
- **どのGatewayでもすべてのAgentに到達可能**（WireGuardメッシュ）

---

### ユースケース4: 開発環境の共有
**アクター**: フリーランス開発者

**前提条件**:
- ローカル開発環境（localhost:3000）でクライアントにデモを見せたい
- ngrokのような一時的なトンネルで十分

**ストーリー**:
1. Agentをインストール済み
2. CLIコマンドで一時トンネルを作成:
   ```
   agent tunnel --port 3000 --temporary
   ```
3. 自動生成されたURL（例: `random-abc123.tunnel.example.com`）が表示される
4. クライアントにURLを共有

**期待される動作**:
- 即座にトンネルが確立
- 一時的なランダムドメインが発行される
- Agentを停止するとトンネルも自動削除
- 管理画面での設定不要

---

### ユースケース5: Docker Composeで簡単公開（CloudFlareスタイル）
**アクター**: Docker利用者

**前提条件**:
- docker-composeでアプリケーションを動かしている
- リバースプロキシ（NginxやTraefik）を置きたくない
- 簡単に外部公開したい
- Controlのアカウントを既に持っている

**ストーリー**:
1. 既存のdocker-compose.ymlにAgentコンテナを追加:
   ```yaml
   services:
     app:
       image: my-app:latest
       ports:
         - "3000:3000"

     agent:
       image: kakuremichi/agent:latest
       environment:
         - CONTROL_URL=https://control.example.com
         - API_KEY=xxx
         # ドメインやターゲットの設定は不要！
   ```
2. `docker-compose up`で起動
3. ControlのWeb UIにアクセス
4. 「Agents」ページで、接続されたAgentを確認（オンライン表示）
5. 「新しいトンネル」ボタンをクリック
6. 接続されたAgentを選択
7. トンネル設定を入力:
   - ドメイン: `myapp.example.com`
   - ターゲット: `app:3000`（Agentから見える宛先）
8. 保存

**期待される動作**:
- Agentは起動しただけで待機状態
- **Web UIから設定した瞬間にトンネルが確立**
- `https://myapp.example.com`で外部からアクセス可能
- **SSL証明書はGatewayが自動取得（Let's Encrypt）**
- リバースプロキシを別途置く必要なし
- **Agentの設定ファイルやdocker-compose.ymlを変更せずに、複数のトンネルを追加できる**

**メリット**:
- docker-compose.ymlに最小限の設定だけ（CONTROL_URLとAPI_KEYのみ）
- ドメインやターゲットはWeb UIで柔軟に管理
- 1つのAgentで複数のサービスを公開可能（Web UIで追加）
- Nginx、Traefik、Caddyなどのリバースプロキシ不要
- SSL証明書の設定・更新が完全自動
- **CloudFlare Tunnelと同じ使い勝手**

---

### ユースケース6: 完全自動SSL対応
**アクター**: インフラ初心者

**前提条件**:
- SSL証明書の取得方法がわからない
- certbotなどのツールを使いたくない
- ドメインは既に持っている

**ストーリー**:
1. ControlとGatewayを起動（初回のみ）
2. DNSでドメインをGatewayに向ける
3. Controlの管理画面でトンネルを作成:
   - ドメイン: `myapp.example.com`
   - ターゲット: `localhost:8080`
4. 保存

**期待される動作**:
- Gatewayが自動的にLet's Encryptから証明書を取得
- HTTPSが即座に有効になる
- 証明書の更新も自動（90日ごと）
- ユーザーは証明書について何も考えなくて良い

**技術的な実装**:
- GatewayにACME protocol対応（Let's Encrypt）
- HTTP-01チャレンジまたはTLS-ALPN-01チャレンジ
- 証明書の自動更新スケジューラー
- 証明書のストレージ（ファイルまたはDB）

---

**その他のユースケース（Phase 2以降）**: `roadmap.md`を参照

---

## 3. 機能要件

### 3.1 必須機能（Must Have）

#### 認証・認可
- [ ] ユーザー登録
- [ ] ログイン・ログアウト
- [ ] セッション管理
- [ ] アクセス制御（誰がどのサービスにアクセスできるか）
- [ ] その他:

#### トンネル管理
- [ ] トンネルの作成（ドメイン、Agent、ターゲットの設定）
- [ ] トンネルの削除
- [ ] トンネルの編集
- [ ] トンネル一覧表示
- [ ] トンネルの有効化・無効化
- [ ] トンネルステータスの監視
- [ ] 自動再接続
- [ ] その他:

#### 入口ノード管理（Gateway - MVP必須）
- [ ] **複数Gatewayの登録・管理（MVP必須）**
- [ ] Gatewayの削除
- [ ] **Gatewayのステータス監視（オンライン/オフライン）**
- [ ] Gatewayの有効化・無効化
- [ ] **Gatewayのヘルスチェック（自動）**
- [ ] **トンネル作成時のGateway選択または自動割り当て**
- [ ] **SSL証明書の自動取得（Let's Encrypt）**
- [ ] **SSL証明書の自動更新**
- [ ] **HTTPからHTTPSへの自動リダイレクト**
- [ ] その他:

#### クライアント管理（Agent）
- [ ] エッジクライアントの登録
- [ ] クライアント認証
- [ ] クライアントステータス監視
- [ ] クライアント設定の配布
- [ ] クライアントとGatewayの紐付け
- [ ] **Dockerコンテナとしての配布（MVP必須）**
- [ ] **Docker Composeサポート（環境変数での設定、MVP必須）**
- [ ] バイナリ配布（各OS対応）
- [ ] その他:

#### UI/管理画面
- [ ] ダッシュボード（全体の状態を把握）
- [ ] サービス管理画面
- [ ] ユーザー管理画面
- [ ] ログ・監視画面
- [ ] その他:

### 3.2 重要機能（Should Have）

- [ ] 複数組織のサポート
- [ ] ロールベースアクセス制御（RBAC）
- [ ] 監査ログ
- [ ] メトリクス収集（帯域幅、接続数など）
- [ ] アラート・通知機能
- [ ] API提供（管理操作をAPIで実行）
- [ ] CLI管理ツール
- [ ] **一時トンネル機能（ngrokライク）**
- [ ] **カスタムドメインサポート**
- [ ] **ワイルドカード証明書対応**
- [ ] その他:

### 3.3 あると良い機能（Nice to Have - MVP範囲内）

- [ ] カスタムドメインの高度な管理
- [ ] トンネルのプレビュー機能
- [ ] エラーページのカスタマイズ
- [ ] その他:

**Phase 2以降の機能**: `roadmap.md`を参照

## 4. 非機能要件

### 4.1 パフォーマンス
- **レイテンシ**:
  - 目標値:
  - 許容値:
- **スループット**:
  - 目標値:
  - 許容値:
- **同時接続数**:
  - 目標値:
  - 許容値:

### 4.2 セキュリティ
- [ ] 通信の暗号化（必須）
- [ ] 認証情報の安全な保管
- [ ] パスワードのハッシュ化
- [ ] セッションの安全な管理
- [ ] HTTPS強制
- [ ] Rate Limiting（DoS対策）
- [ ] その他:

**セキュリティ基準**:
- 準拠すべき規格・ガイドライン:

### 4.3 可用性
- **稼働率目標**:
- **ダウンタイム許容**:
- **バックアップ要件**:
- **災害復旧要件**:

### 4.4 スケーラビリティ
- **想定ユーザー数**:
  - 初期:
  - 1年後:
  - 3年後:
- **想定サービス数**:
  - 初期:
  - 1年後:
  - 3年後:
- **水平スケーリング**: 必要 / 不要
- **垂直スケーリング**: 必要 / 不要

### 4.5 保守性・運用性
- [ ] ログの収集と保管
- [ ] モニタリング機能
- [ ] ヘルスチェック
- [ ] 設定のバックアップ・リストア
- [ ] アップデート機能
- [ ] ロールバック機能
- [ ] その他:

### 4.6 移植性
- **サポートOS**:
  - サーバー側:
  - クライアント側:
- **デプロイ方法**:
  - [ ] バイナリ配布
  - [ ] Dockerコンテナ
  - [ ] Kubernetes
  - [ ] その他:

### 4.7 ユーザビリティ
- **ターゲット**: 技術者 / 非技術者 / 両方
- **ドキュメント要件**:
  - [ ] インストールガイド
  - [ ] ユーザーガイド
  - [ ] API仕様書
  - [ ] トラブルシューティングガイド
- **多言語対応**: 必要 / 不要
  - 対応言語:

## 5. 技術スタック

### 5.1 Control（管理サーバー）

**言語・ランタイム**:
- Node.js 20+
- TypeScript 5+

**フロントエンド**:
- Next.js 15 (App Router)
- React 19
- Radix UI（UIコンポーネント）
- Tailwind CSS（スタイリング）

**バックエンド**:
- Express 5（REST API）
- WebSocket (ws)（リアルタイム通信）

**データベース**:
- SQLite（MVP）
- Drizzle ORM（PostgreSQL対応も視野に）

**認証**:
- Oslo（セッション管理）
- Argon2（パスワードハッシュ）

**バリデーション**:
- Zod

### 5.2 Gateway（入口ノード）

**言語**:
- Go 1.23+

**主要機能**:
- HTTP/HTTPSサーバー（ポート443）
- **WireGuardサーバー（ポート51820/udp）**
- トンネル中継
- SSL証明書管理（Let's Encrypt / ACME protocol）
- ヘルスチェックエンドポイント

**WireGuard実装**:
- ネイティブLinux WireGuardまたはwireguard-go

### 5.3 Agent（エッジクライアント）

**言語**:
- Go 1.23+

**主要機能**:
- WebSocketクライアント（Controlとの通信）
- **WireGuardクライアント（Gatewayとのトンネル）**
- TCP/UDPプロキシ
- ローカルサービスへの接続

**WireGuard実装**:
- wireguard-go + netstack（ユーザースペース、ポート開放不要）
- **1つのWireGuardインターフェースで複数Gatewayに接続**
- 仮想IPアドレス: 10.0.0.100/24（同一ネットワークに全Gatewayが参加）
- **AllowedIPsで通信相手を制限**（Agent ⇔ Gateway のみ、Agent間は不可）

### 5.4 実行環境

**デプロイ方法**:
- Dockerコンテナ（MVP必須）
- Docker Compose

**最小システム要件**（1コンポーネントあたり）:
- CPU: 1コア
- メモリ: 512MB
- ストレージ: 100MB
- ネットワーク: インターネット接続

### 5.5 外部依存

**必須の外部サービス**:
- なし（完全セルフホスト可能）

**オプションの外部サービス**:
- DNS（ドメインをGatewayに向ける）
- Let's Encrypt（SSL証明書自動取得）

### 5.6 ライセンス

**採用予定ライセンス**:
- MIT License

**利用可能なライブラリ**:
- MITまたは互換性のあるライセンス（Apache 2.0、BSD等）

## 6. MVP（Phase 1）スコープ

**期間**: TBD
**目標**: 基本的なトンネル機能とDocker対応で動作するシステム

### 含める機能

**コアコンポーネント**:
- Control（管理サーバー）
  - 基本的なWebUI
  - REST API
  - WebSocketサーバー
  - データベース（SQLite）
- **Gateway（入口ノード - 複数配置可能）**
  - トンネル中継
  - SSL証明書自動取得（Let's Encrypt）
  - HTTPSリダイレクト
  - ヘルスチェックエンドポイント
- Agent（エッジクライアント）
  - トンネル確立
  - ローカルプロキシ

**必須機能**:
- ✅ **Dockerコンテナとしての配布（3コンポーネント全て）**
- ✅ **Docker Composeサポート**
- ✅ **複数Gateway対応（登録・管理・監視）**
- ✅ **Gatewayのヘルスチェック・自動検出**
- ✅ ユーザー認証（登録・ログイン）
- ✅ トンネル管理（作成・削除・一覧・編集）
- ✅ Agent管理（登録・認証・ステータス監視）
- ✅ SSL証明書自動取得・更新
- ✅ シンプルで使いやすいWebUI

### 含めない機能（Phase 2以降に延期）

- ❌ Kubernetes統合
- ❌ 複数組織サポート
- ❌ RBAC（ロールベースアクセス制御）
- ❌ 高度な監視・メトリクス
- ❌ OAuth/OIDC統合
- ❌ 一時トンネル機能
- ❌ CLI管理ツール
- ❌ バイナリ配布

**詳細は `roadmap.md` を参照**

### 実現できるユースケース

- ✅ ユースケース1: シンプルなWebアプリケーションの公開
- ✅ ユースケース2: 複数サービスの公開
- ✅ ユースケース3: 高可用性構成（複数Gateway対応）
- ✅ ユースケース5: Docker Composeで簡単公開
- ✅ ユースケース6: 完全自動SSL対応

### MVPの成功基準

**技術的成功基準**:
- [ ] `docker-compose up`一発で全コンポーネントが起動する
- [ ] Web UIでトンネルを作成できる
- [ ] SSL証明書が自動取得される
- [ ] 外部から`https://`でアクセスできる
- [ ] 複数のGatewayを配置し、どのGatewayでもすべてのAgentにアクセスできる

**ユーザー体験**:
- [ ] 初めてのユーザーが30分以内にトンネルを張れる
- [ ] docker-compose.ymlに数行追加するだけで使える
- [ ] SSL証明書について何も考えなくて良い

---

**作成日**: 2025-11-22
**最終更新**: 2025-11-22
