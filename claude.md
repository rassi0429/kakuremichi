# Kokoa Proxy 2 - アーキテクチャ検討

## プロジェクトの目的

Pangolinを参考にしながら、独自のトンネル型リバースプロキシシステムを構築する。
ファイアウォール背後のプライベートネットワークへの安全なアクセスを実現することが目標。

## 解決したい課題

1. **プライベートネットワークへのリモートアクセス**
   - ファイアウォールやNATの背後にあるサービスに安全にアクセスしたい
   - VPNのような複雑な設定なしにアクセス可能にしたい

2. **セキュリティとアクセス制御**
   - 誰がどのサービスにアクセスできるかを細かく制御したい
   - 認証・認可の仕組みが必要

3. **管理の容易性**
   - Webインターフェースで簡単に管理できるようにしたい
   - サービスの追加・削除を動的に行いたい

4. **スケーラビリティ**
   - 複数のプライベートネットワーク、複数のサービスに対応したい
   - 将来的には多数のユーザー・組織に対応したい

## Pangolinから学んだこと

### 良い点
- コントロールプレーン・データプレーンの分離
- WireGuardによる暗号化トンネル
- WebSocketによるリアルタイム制御
- 軽量なエッジクライアント設計

### 検討が必要な点
- コンポーネントが多く複雑（Control Plane, Gerbil, Newt, Badger, Reverse Proxy）
- 技術スタックの混在（TypeScript, Go, Gerbil Scheme）
- Gerbilの役割が不明確（なぜ別コンポーネントなのか？）

## アーキテクチャの方向性（検討中）

### オプション1: シンプル構成
```
[管理サーバー] ←WebSocket→ [エッジクライアント] → [プライベートアプリ]
     ↑
[外部ユーザー（認証済み）]
```

**メリット**:
- シンプル、理解しやすい
- 開発が早い

**デメリット**:
- スケーラビリティに課題
- トンネル管理と認証が同じコンポーネントに

### オプション2: 2層構成
```
[コントロールプレーン] ←WebSocket→ [エッジクライアント] → [プライベートアプリ]
        ↓                                ↑
[トンネルゲートウェイ] ─────WireGuard────┘
        ↑
[外部ユーザー（認証済み）]
```

**メリット**:
- コントロールとデータプレーンの分離
- スケーラブル

**デメリット**:
- やや複雑
- コンポーネント間の通信設計が必要

### オプション3: Pangolin型（3層構成）
```
[コントロールプレーン]
        ↓ WebSocket
[トンネルマネージャー] ←WireGuard→ [エッジクライアント] → [プライベートアプリ]
        ↑
[認証ゲートウェイ]
        ↑
[外部ユーザー]
```

**メリット**:
- 高度な制御が可能
- 各コンポーネントが独立

**デメリット**:
- 最も複雑
- 開発・運用コストが高い

## 検討事項

### 1. トンネル技術の選択

**WireGuard**
- 利点: 高速、セキュア、モダン
- 欠点: カーネルモジュール必要（ユーザースペース実装もあるが）

**SSH Tunneling**
- 利点: 既存技術、導入が簡単
- 欠点: パフォーマンス、スケーラビリティ

**カスタムプロトコル（WebSocket + TLS）**
- 利点: 柔軟、ファイアウォールフレンドリー
- 欠点: セキュリティリスク、パフォーマンス

**→ 検討結果: ?**

### 2. 認証・認可の設計

**認証方法の候補**:
- パスワード認証（基本）
- APIキー
- OAuth/OIDC（エンタープライズ向け）
- WebAuthn（将来）

**認可モデルの候補**:
- シンプルなACL（ユーザー ⇔ サービスのマッピング）
- RBAC（ロールベース）
- ABAC（属性ベース、コンテキスト認識）

**→ 検討結果: ?**

### 3. データフローの設計

**データプレーン（実際のトラフィック）はどこを通るか？**

**パターンA: ダイレクトトンネル**
```
外部ユーザー → コントロールプレーン（認証） → エッジクライアント → アプリ
                       ↓
              トンネル確立後は直接通信
```

**パターンB: ゲートウェイ経由**
```
外部ユーザー → ゲートウェイ → トンネル → エッジクライアント → アプリ
                   ↑
         コントロールプレーンで認証・ルーティング決定
```

**→ 検討結果: ?**

### 4. エッジクライアントの役割

**必須機能**:
- トンネル確立・維持
- ローカルサービスへのプロキシ

**オプション機能**:
- Docker統合（コンテナ自動検出）
- ヘルスチェック
- メトリクス収集
- 複数サービスのプロキシ

**→ 検討結果: ?**

### 5. 技術スタック

**サーバーサイド（コントロールプレーン）**:
- Node.js + TypeScript?
- Go?
- Python?

**エッジクライアント**:
- Go（軽量、クロスプラットフォーム）
- Rust（パフォーマンス重視）
- Node.js（TypeScriptで統一）

**データベース**:
- SQLite（シンプル）
- PostgreSQL（スケーラブル）
- 両対応？

**フロントエンド**:
- Next.js + React（フルスタック）
- Vue.js + 別途API
- シンプルなHTML + vanilla JS

**→ 検討結果: ?**

### 6. 開発戦略

**アプローチA: MVP優先**
- 最小限の機能で動くものをまず作る
- 認証なし、1対1接続のみ
- 動いたら機能追加

**アプローチB: 設計優先**
- アーキテクチャをしっかり設計
- 拡張性を考慮した実装
- 初期投資は大きいが後が楽

**→ 検討結果: ?**

## 次に決めること

1. [ ] どのアーキテクチャオプションを選ぶか（シンプル / 2層 / 3層）
2. [ ] トンネル技術の選択（WireGuard / SSH / カスタム）
3. [ ] データフローのパターン（ダイレクト / ゲートウェイ経由）
4. [ ] 技術スタックの決定（言語、フレームワーク、DB）
5. [ ] 開発アプローチ（MVP優先 / 設計優先）
6. [ ] MVPの範囲定義（どこまでの機能を最初に実装するか）

## メモ・アイデア

（ここに検討中のアイデアや気づいたことをメモ）

---

**最終更新**: 2025-11-22
